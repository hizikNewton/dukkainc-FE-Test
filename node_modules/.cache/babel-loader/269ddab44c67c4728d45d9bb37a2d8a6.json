{"ast":null,"code":"import validator from \"validator\";\nexport function ValidateData(data, rules) {\n  let errors = {};\n  Object.keys(data).forEach(field => {\n    if (rules.hasOwnProperty(field)) {\n      let fielderrors = [];\n      let val = data[field];\n\n      if (rules[field].required && validator.isEmpty(val)) {\n        fielderrors.push(\"Value required\");\n      }\n\n      if (!validator.isEmpty(data[field])) {\n        if (rules[field].strAlpha && !validator.matches(val, /^[a-z]([-']?[a-z]+)*( [a-z]([-']?[a-z]+)*)+$/gi)) {\n          fielderrors.push(\"value must be a fullname eg 'John Doe'\");\n        }\n\n        if (rules[field].minlength && !validator.isLength(val, {\n          min: rules[field].minlength\n        })) {\n          fielderrors.push(`Enter at least ${rules[field].minlength}` + \" characters\");\n        }\n\n        if (rules[field].alphanumeric && !validator.isAlphanumeric(val)) {\n          fielderrors.push(\"field can only contain alphanumeric values\");\n        }\n\n        if (rules[field].alpha && !validator.isAlpha(val)) {\n          fielderrors.push(\"Enter only letters\");\n        }\n\n        if (rules[field].email && !validator.isEmail(val)) {\n          fielderrors.push(\"Enter a valid email address\");\n        }\n\n        if (rules[field].numeric && !validator.isMobilePhone(val)) {\n          fielderrors.push(\"Enter a valid phone number\");\n        }\n      }\n\n      if (fielderrors.length > 0) {\n        errors[field] = fielderrors;\n      }\n    }\n  });\n  return errors;\n}\n_c = ValidateData;\n\nvar _c;\n\n$RefreshReg$(_c, \"ValidateData\");","map":{"version":3,"sources":["/home/ire/Dev/frontend-engineer-interview/app/src/utils/validate.ts"],"names":["validator","ValidateData","data","rules","errors","Object","keys","forEach","field","hasOwnProperty","fielderrors","val","required","isEmpty","push","strAlpha","matches","minlength","isLength","min","alphanumeric","isAlphanumeric","alpha","isAlpha","email","isEmail","numeric","isMobilePhone","length"],"mappings":"AAAA,OAAOA,SAAP,MAAsB,WAAtB;AAsBA,OAAO,SAASC,YAAT,CAAsBC,IAAtB,EAAmCC,KAAnC,EAAiD;AACtD,MAAIC,MAAe,GAAG,EAAtB;AACAC,EAAAA,MAAM,CAACC,IAAP,CAAYJ,IAAZ,EAAkBK,OAAlB,CAA2BC,KAAD,IAAW;AACnC,QAAIL,KAAK,CAACM,cAAN,CAAqBD,KAArB,CAAJ,EAAiC;AAC/B,UAAIE,WAAW,GAAG,EAAlB;AACA,UAAIC,GAAG,GAAGT,IAAI,CAACM,KAAD,CAAd;;AACA,UAAIL,KAAK,CAACK,KAAD,CAAL,CAAaI,QAAb,IAAyBZ,SAAS,CAACa,OAAV,CAAkBF,GAAlB,CAA7B,EAAqD;AACnDD,QAAAA,WAAW,CAACI,IAAZ,CAAiB,gBAAjB;AACD;;AACD,UAAI,CAACd,SAAS,CAACa,OAAV,CAAkBX,IAAI,CAACM,KAAD,CAAtB,CAAL,EAAqC;AACnC,YACEL,KAAK,CAACK,KAAD,CAAL,CAAaO,QAAb,IACA,CAACf,SAAS,CAACgB,OAAV,CACCL,GADD,EAEC,gDAFD,CAFH,EAME;AACAD,UAAAA,WAAW,CAACI,IAAZ,CAAiB,wCAAjB;AACD;;AACD,YACEX,KAAK,CAACK,KAAD,CAAL,CAAaS,SAAb,IACA,CAACjB,SAAS,CAACkB,QAAV,CAAmBP,GAAnB,EAAwB;AAAEQ,UAAAA,GAAG,EAAEhB,KAAK,CAACK,KAAD,CAAL,CAAaS;AAApB,SAAxB,CAFH,EAGE;AACAP,UAAAA,WAAW,CAACI,IAAZ,CACG,kBAAiBX,KAAK,CAACK,KAAD,CAAL,CAAaS,SAAU,EAAzC,GAA6C,aAD/C;AAGD;;AACD,YAAId,KAAK,CAACK,KAAD,CAAL,CAAaY,YAAb,IAA6B,CAACpB,SAAS,CAACqB,cAAV,CAAyBV,GAAzB,CAAlC,EAAiE;AAC/DD,UAAAA,WAAW,CAACI,IAAZ,CAAiB,4CAAjB;AACD;;AACD,YAAIX,KAAK,CAACK,KAAD,CAAL,CAAac,KAAb,IAAsB,CAACtB,SAAS,CAACuB,OAAV,CAAkBZ,GAAlB,CAA3B,EAAmD;AACjDD,UAAAA,WAAW,CAACI,IAAZ,CAAiB,oBAAjB;AACD;;AACD,YAAIX,KAAK,CAACK,KAAD,CAAL,CAAagB,KAAb,IAAsB,CAACxB,SAAS,CAACyB,OAAV,CAAkBd,GAAlB,CAA3B,EAAmD;AACjDD,UAAAA,WAAW,CAACI,IAAZ,CAAiB,6BAAjB;AACD;;AACD,YAAIX,KAAK,CAACK,KAAD,CAAL,CAAakB,OAAb,IAAwB,CAAC1B,SAAS,CAAC2B,aAAV,CAAwBhB,GAAxB,CAA7B,EAA2D;AACzDD,UAAAA,WAAW,CAACI,IAAZ,CAAiB,4BAAjB;AACD;AACF;;AAED,UAAIJ,WAAW,CAACkB,MAAZ,GAAqB,CAAzB,EAA4B;AAC1BxB,QAAAA,MAAM,CAACI,KAAD,CAAN,GAAgBE,WAAhB;AACD;AACF;AACF,GA3CD;AA4CA,SAAON,MAAP;AACD;KA/CeH,Y","sourcesContent":["import validator from \"validator\";\ntype rules = {\n  required: boolean;\n  minlength: number;\n  alpha: boolean;\n  email: boolean;\n  numeric: boolean;\n  strAlpha: boolean;\n  alphanumeric: boolean;\n};\n\nexport interface IRule {\n  [x: string]: Partial<rules>;\n}\nexport interface IData {\n  [x: string]: any;\n}\n\ninterface IErrors {\n  [field: string]: Array<string>;\n}\n\nexport function ValidateData(data: IData, rules: IRule) {\n  let errors: IErrors = {};\n  Object.keys(data).forEach((field) => {\n    if (rules.hasOwnProperty(field)) {\n      let fielderrors = [];\n      let val = data[field];\n      if (rules[field].required && validator.isEmpty(val)) {\n        fielderrors.push(\"Value required\");\n      }\n      if (!validator.isEmpty(data[field])) {\n        if (\n          rules[field].strAlpha &&\n          !validator.matches(\n            val,\n            /^[a-z]([-']?[a-z]+)*( [a-z]([-']?[a-z]+)*)+$/gi\n          )\n        ) {\n          fielderrors.push(\"value must be a fullname eg 'John Doe'\");\n        }\n        if (\n          rules[field].minlength &&\n          !validator.isLength(val, { min: rules[field].minlength })\n        ) {\n          fielderrors.push(\n            `Enter at least ${rules[field].minlength}` + \" characters\"\n          );\n        }\n        if (rules[field].alphanumeric && !validator.isAlphanumeric(val)) {\n          fielderrors.push(\"field can only contain alphanumeric values\");\n        }\n        if (rules[field].alpha && !validator.isAlpha(val)) {\n          fielderrors.push(\"Enter only letters\");\n        }\n        if (rules[field].email && !validator.isEmail(val)) {\n          fielderrors.push(\"Enter a valid email address\");\n        }\n        if (rules[field].numeric && !validator.isMobilePhone(val)) {\n          fielderrors.push(\"Enter a valid phone number\");\n        }\n      }\n\n      if (fielderrors.length > 0) {\n        errors[field] = fielderrors;\n      }\n    }\n  });\n  return errors;\n}\n"]},"metadata":{},"sourceType":"module"}